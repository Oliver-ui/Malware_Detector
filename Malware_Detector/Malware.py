from tkinter import *
from tkinter import filedialog
from Behaviour_scan import *
from Behaviour_task import *
from ChangeConfiguration import ConfigurationChange
from Signature_task import *
from Signature_scan import *
from State import *
from tkinter.filedialog import askdirectory
from tkinter.filedialog import askopenfilename

import tkinter.ttk
import os
import sys
import shutil
import time
import import_ipynb
import Feature_extraction as fe
import pandas as pd
import numpy as np

# Configurations of each screen in this application.
class Configure_screen(object):
    def __init__(self, win):
        screen_width = win.winfo_screenwidth()
        screen_height = win.winfo_screenheight()

        ww = 950
        wh = 500

        x = (screen_width - ww) / 2
        y = (screen_height - wh) / 2

        win.geometry('%dx%d+%d+%d' %(ww,wh,x,y))
        win.title("Malware Detecter")
        win.configure(bg="black")

# Logic and configuration of Start Screen.
class Start_screen(object):
    def go_choose_file(self):
        self.root.destroy()
        Choose_screen()

    def __init__(self):
        # Create root screen and configure it.
        self.root = Tk()
        Configure_screen(self.root)

        self.frame_empty = Frame(self.root, width=800, height=120)
        self.frame_empty.configure(bg="black")
        self.frame_empty.pack()

        # Show the application name.
        self.name = Label(self.root, text="Malware", fg="white", bg="black", font=('Arial', 120))
        self.name.pack()

        self.frame_btn = Frame(self.root)
        self.frame_btn.configure(bg="black")
        self.frame_btn.pack(pady=10)

        # Create button to exit and select file.
        scan_btn = Button(self.frame_btn, width=15, height=3, text="Submit file", fg="white", bg="grey", bd=1, font=('bold', 20), command=self.go_choose_file)
        scan_btn.pack(side=LEFT, padx=15)

        exit_btn = Button(self.frame_btn, width=15, height=3, text="Exit", fg="white", bg="grey", bd=1, font=('bold', 20), command=sys.exit)
        exit_btn.pack(padx=15)

        self.root.mainloop()

"""
Allow user to select scan type and submit them in to different scan tasks.
Sample files are fixed but different when user choose different scan.
"""
class Choose_screen(object):

    # Check which scan type is selected
    def which_scan_type(self):
        global scan_type

        if self.iv_default.get() == 1:
            self.scan_type = "Signature"

            if self.read_file_type == "Files":
                self.read_files_signature()

            else:
                self.read_folder_signature()
                
        else:
            self.scan_type = "Behaviour"

            if self.read_file_type == "Files":
                self.read_files_behaviour()

            else:
                self.read_folder_behaviour()


        scan_type = self.scan_type
        print(scan_type)
        

    def read_files_signature(self):
        global task_list
        
        if task_list:
            task_list = []

        all_files_path = ""

        for file_path in self.files_path:
            task_list.append(file_path)
            all_files_path += file_path

        abbreviation_path = ""
        if len(all_files_path) > 50:
            abbreviation_path = all_files_path[:45] + "..."
            self.v.set(abbreviation_path)

        else:
            self.v.set(all_files_path)
        
        print(task_list)

    def read_folder_signature(self):
        global task_list
        
        if task_list:
            task_list = []

        abbreviation_path = ""

        if len(self.folder_path) > 50:
            abbreviation_path = self.folder_path[:45] + "..."
            self.v.set(abbreviation_path)
        
        else:
            self.v.set(self.folder_path)

        # Read all files under selected folder
        for file in self.file_list:
            file_extend = self.folder_path + '/' + file
            task_list.append(file_extend)

        print(task_list)

    def read_files_behaviour(self):
        global task_list
        
        if task_list:
            task_list = []

        all_files_path = ""
        target_dir = "C:\\Users\\12051\\Desktop\\Malware_Detector\\BehaviourTestSamples"
        exist_files = os.listdir(target_dir)

        for file_path in self.files_path:
            pos = file_path.rfind('/')
            print(file_path[pos+1:])
            print(file_path[pos+1:] in exist_files)
            if (os.path.isfile(file_path) and file_path[pos+1:] not in exist_files):
                shutil.copy(file_path, target_dir)

            task_list.append(file_path)
            all_files_path += file_path

        abbreviation_path = ""
        if len(all_files_path) > 50:
            abbreviation_path = all_files_path[:45] + "..."
            self.v.set(abbreviation_path)

        else:
            self.v.set(all_files_path)

        print(task_list)

    def read_folder_behaviour(self):
        global task_list
        
        if task_list:
            task_list = []

        abbreviation_path = ""
        target_dir = "C:\\Users\\12051\\Desktop\\Malware_Detector\\BehaviourTestSamples"
        exist_files = os.listdir(target_dir)

        if len(self.folder_path) > 50:
            abbreviation_path = self.folder_path[:45] + "..."
            self.v.set(abbreviation_path)
        
        else:
            self.v.set(self.folder_path)

        for file in self.file_list:
            file_extend = self.folder_path + '/' + file
            print(file)
            print(file in exist_files)
            # For behaviour method, copy all files under selected folder into target folder
            if (os.path.isfile(file_extend) and (file not in exist_files)):
                shutil.copy(file_extend, target_dir)
            task_list.append(file_extend)


        print(task_list)

    # Enables user to select files
    def read_selected_files(self):
        # Avoid adding extra files
        global task_list
        if task_list:
            task_list = []
        
        # Read files
        self.files_path = filedialog.askopenfilenames()
        self.read_file_type = "Files"
        print(self.files_path)


        all_files_path = ""
        for file_path in self.files_path:
            all_files_path += file_path

        abbreviation_path = ""
        if len(all_files_path) > 50:
            abbreviation_path = all_files_path[:45] + "..."
            self.v.set(abbreviation_path)

        else:
            self.v.set(all_files_path)

    # Enable user to select directory
    def read_selected_folder(self):
        # Avoid adding extra files
        global task_list
        if task_list:
            task_list = []

        self.folder_path = filedialog.askdirectory()
        self.read_file_type = "Folder"
        self.file_list = os.listdir(self.folder_path)

        abbreviation_path = ""
        if len(self.folder_path) > 50:
            abbreviation_path = self.folder_path[:45] + "..."
            self.v.set(abbreviation_path)
        
        else:
            self.v.set(self.folder_path)
        print(self.folder_path)
    
    # Load and change the configuration of process monitor file according to the selected files
    def load_configuration(self):
        change_config = ConfigurationChange()
        # file_name_list = os.listdir("C:\\Users\\12051\\Desktop\\Malware_Detector\\BehaviourTestSamples")

        if self.scan_type == "Behaviour":
            file_name_list = []
            if self.read_file_type == "Folder":
                file_name_list = os.listdir(self.folder_path)
            else:
                for file in self.files_path:
                    pos = file.rfind('/')
                    file_name_list.append(file[pos+1:]) 

        change_config.write_file_name(file_name_list)

        init_config_procmon = change_config.load_initial_configuration()
        change_config.change_configuration(init_config_procmon)

    def back(self):
        # Destroy choose screen and go back to start screen
        self.root.destroy()
        Start_screen()

    def go_processing_screen(self):
        # Go to next screen only if file is submitted
        if self.v.get() != "" and task_list:
            self.root.destroy()
            Progcessing_screen()
        
        else:
            self.root.destroy()
            Choose_screen()

    def __init__(self):
        # Create root screen and configure it
        self.root = Tk()
        Configure_screen(self.root)

        self.has_copied = False

        # Create frame to load label of this screen
        self.frame_empty = Frame(self.root, width=800, height=50)
        self.frame_empty.configure(bg="black")
        self.frame_empty.pack()

        # Configure the font type and size
        self.name = Label(self.root, text="Scan file", fg="white", bg="black", font=('Arial', 50))
        self.name.pack(pady=20)

        self.frame_select = Frame(self.root, pady=20)
        self.frame_select.configure(bg="black")
        self.frame_select.pack()

        # Show the file path of samples will be scanned
        self.v = StringVar()
        Label(self.frame_select, text="Selected file(folder):  ", fg="white", bg="black", font=("bold", 15)).pack(padx=5, side=LEFT)
        Label(self.frame_select, width=50, textvariable = self.v, bg="black", fg="white", font=("bold", 12, 'bold')).pack(padx=10, side=LEFT)
        Button(self.frame_select, text="Select Files", command=self.read_selected_files, width=15, height=2, fg="white", bg="grey", font=("bold",12)).pack()
        Button(self.frame_select, text="Select Folder", command=self.read_selected_folder, width=15, height=2, fg="white", bg="grey", font=("bold",12)).pack()

        
        self.frame_rb = Frame(self.root)
        self.frame_rb.configure(bg="black")
        self.frame_rb.pack()

        # Choose scan type
        self.iv_default = IntVar()
        Label(self.frame_rb, text="Select a scan type", font=("bold", 25), background="black", fg="white").pack(side=LEFT, padx=30)
        Radiobutton(self.frame_rb, text="Signature", fg="white", bg='black', value=1, variable=self.iv_default, selectcolor="black", highlightcolor = 'purple', font=("bold", 25, 'bold'), command=self.which_scan_type).pack()
        Radiobutton(self.frame_rb, text="Behaviour", fg="white", bg='black', value=2, variable=self.iv_default, selectcolor="black", font=("bold", 25, 'bold'), command=self.which_scan_type).pack(pady=5)
        Button(self.root, text="Load", width=8, height=2, command=self.load_configuration, fg="white", bg="grey", font=("bold",10)).place(x=780, y=360)

        self.frame_btn = Frame(self.root)
        self.frame_btn.configure(bg="black")
        self.frame_btn.pack(pady=10)

        # Create start and back buttons and pack them
        Button(self.frame_btn, width=15, height=3, text="Back", command=self.back, fg="white", bg="grey", font=("bold",15)).pack(side=LEFT)
        Button(self.frame_btn, width=15, height=3, text="Scan", command=self.go_processing_screen, fg="white", bg="grey", font=("bold",15)).pack(padx=20)

        self.root.mainloop()

"""
Scan all submitted files and show current progress in progress bar.
Perform different actions refers to different actions.
"""
class Progcessing_screen(object):
    # Cancel the processing task and go back to last screen
    def cancel(self):
        self.root.destroy()
        Choose_screen()

    # Configure the progress bar
    def progress_show(self):
        self.progressbar['value'] = 0
        self.progressbar['maximum'] = 100
        self.progress_loading()

    # Perform different actions refers to selected scan type
    def progress_loading(self):

        # Signature method
        if scan_type == "Signature":
            task_done = 0

            # Generate instance of signature scan
            signature_scan = SignatureScan()

            # Read all file names and create task instance of them each
            for file_path in task_list:
                signature_task = SignatureTask()
                signature_task.set_file_path(file_path)
                signature_scan.tasks.append(signature_task)
            
            # Get the hash list of malware database
            signature_scan.hash_list_unsort = signature_scan.read_hash_list()
            signature_scan.hash_list = signature_scan.sort_hash_list(signature_scan.hash_list_unsort)

            # Scan all the submitted file and classify them
            for task in signature_scan.tasks:
                task.state = State.PROCESSING
                file_hash = signature_scan.get_file_hash(task.get_file_path())
                task.hash = file_hash
                self.file_name.set(task.get_file_path())
                if signature_scan.find_match(task.hash):
                    task.result = "Malware"
                task.state = State.DONE
                
                # Update progress bar according to current progress
                if task.state == State.DONE:
                    task_done += 1
                    self.progressbar['value'] += (1 / len(signature_scan.tasks)) * 100
                    self.current_status.set(str(task_done) + '/' + str(len(signature_scan.tasks)))

                self.root.update()
                time.sleep(0.3)
            
            # Directly go to the result screen when all files are scanned
            if task_done == len(signature_scan.tasks):
                self.root.destroy()
                Result_screen(signature_scan.tasks)
        
        # Behaviour method
        else:
            behaviour_scan = BehaviourScan()
            # Record how many files are submitted
            task_done = 0
            task_num = 0

            # Append every task into behaviour scan task
            for file_path in task_list:
                task_num += 1
                behaviour_task = BehaviourTask()
                behaviour_task.set_file_path(file_path)
                behaviour_scan.tasks.append(behaviour_task)

            # Obtain behaviour features, load the saved model and get the prediction
            task_features = behaviour_scan.get_result_features(task_num)
            trained_model = behaviour_scan.get_trained_model()
            task_features_np = np.array(task_features)
            prediction = behaviour_scan.get_prediction(trained_model, task_features_np)

            # The order of prediction results is the same as the order that files are submitted
            # Use which_file to indicate which file is being executed
            which_file = 0
            for task in behaviour_scan.tasks:
                self.file_name.set(task.get_file_path())
                if prediction[which_file] == 0:
                    task.result = "Malware"
                task.state = State.DONE

                # Change the status of progress bar
                if task.state == State.DONE:
                    task_done += 1
                    self.progressbar['value'] += (1 / len(behaviour_scan.tasks)) * 100
                    self.current_status.set(str(task_done) + '/' + str(len(behaviour_scan.tasks)))

                which_file += 1
                self.root.update()
                time.sleep(0.3)

            # Direct to the result screen when all tasks are performed
            if task_done == len(behaviour_scan.tasks):
                self.root.destroy()
                Result_screen(behaviour_scan.tasks)

            
    def __init__(self):
        # Configure the screen
        self.root = Tk()
        Configure_screen(self.root)

        self.frame_empty = Frame(self.root, width=800, height=50)
        self.frame_empty.configure(bg="black")
        self.frame_empty.pack()

        self.fram_progress = Frame(bg="black")
        self.fram_progress.pack()

        # Put a progress bar on the screen
        Label(self.fram_progress, text="Process: ", fg="white", bg="black", font=('Arial', 60, 'bold')).pack(pady=15)
        self.progressbar = tkinter.ttk.Progressbar(self.fram_progress, length=300)
        self.progressbar.pack(pady=20)
        
        # Indicate the current state
        self.current_status = StringVar()
        Label(self.fram_progress, width=20, textvariable = self.current_status, bg="black", fg="white", font=("bold", 20, 'bold')).pack(pady=10)
        self.current_status.set("")
        
        self.frame_name = Frame(self.root)
        self.frame_name.configure(bg="black")
        self.frame_name.pack()

        # Show which file is processing at this stage
        self.file_name = StringVar()
        Label(self.frame_name, width=100, textvariable = self.file_name, bg="black", fg="white", font=("bold", 15, 'bold')).pack()
        self.file_name.set("")

        self.frame_btn = Frame(self.root, pady=30)
        self.frame_btn.configure(bg="black")
        self.frame_btn.pack()

        Button(self.frame_btn, width=15, height=3, text="Start", command=self.progress_show, fg="white", bg="grey", font=("bold",20)).pack(side=LEFT)
        Button(self.frame_btn, width=15, height=3, text="Cancel", command=self.cancel, fg="white", bg="grey", font=("bold",20)).pack(padx=15)
        
        self.root.mainloop()

"""
Present result of all submitted files and indicate if they are malware of benign.
You can click the file path and see more detailed information of one single file.
The file can be deleted in detailed info page.
"""
class Result_screen(object):

    # Back to last screen
    def back(self):
        self.root.destroy()
        Choose_screen()

    # Close this application
    def finish(self):
        self.root.destroy()

    # Close the detailed page screen
    def detail_info_win_finish(self):
        self.detail_info_window.destroy()

    # Control the movement of mouse wheel
    def on_mouse_wheel(self, event):
        self.canvas.yview_scroll(-1*(event.delta // 120), "units")

    # Delete file if it exists
    def delete_file(self, file_path):
        if os.path.exists(file_path):
            os.remove(file_path)
            self.detail_info_win_finish()
            self.refresh_result(file_path)

    # Refresh the result screen when one file is deleted
    def refresh_result(self, deleted_file):

        if not self.tasks:
            return

        for task in self.tasks:
            if task.file_path == deleted_file:
                self.tasks.remove(task)

        self.finish()

        Result_screen(self.tasks)

    # Configure and content in detailed page
    def check_detail(self, file_path, scan_type, result):
        # Set the width and height of the detailed page
        self.detail_info_window = Tk()
        screen_width = self.detail_info_window.winfo_screenwidth()
        screen_height = self.detail_info_window.winfo_screenheight()

        ww = 850
        wh = 350

        x = (screen_width - ww) / 2
        y = (screen_height - wh) / 2

        self.detail_info_window.geometry('%dx%d+%d+%d' %(ww,wh,x,y))
        self.detail_info_window.title("Scan Information")
        self.detail_info_window.configure(bg="lavender")

        self.frame_invisible = Frame(self.detail_info_window)
        self.frame_invisible.configure(bg="lavender", height=20)
        self.frame_invisible.pack()

        # Display the result
        Label(self.detail_info_window, text="File Path:   " +  file_path, fg="black", bg="lavender", font=("bold", 12)).pack(pady=10)
        Label(self.detail_info_window, text="Scan Type:   " +  scan_type, fg="black", bg="lavender", font=("bold", 20)).pack(pady=10)
        Label(self.detail_info_window, text="Scan Result:   " +  result, fg="black", bg="lavender", font=("bold", 20)).pack(pady=10)

        self.btn_frame_detail = Frame(self.detail_info_window)
        self.btn_frame_detail.configure(bg="lavender", width=200)
        self.btn_frame_detail.pack(side=BOTTOM, pady=20)

        Button(self.btn_frame_detail, width=30, height=3, text="Delete", command=lambda:self.delete_file(file_path), bg='grey', fg='white', font=("bold",15)).pack(padx=10, pady=5, side=LEFT)
        Button(self.btn_frame_detail, width=30, height=3, text="Close", command=self.detail_info_win_finish, bg='grey', fg='white', font=("bold",15)).pack(padx=5, pady=5)

    def __init__(self, tasks):
        
        # Configure screen 
        self.root = Tk()
        Configure_screen(self.root)

        # Rrcord length of tasks
        self.tasks = tasks
        
        # Create canvas on root screen since scroll bar needs to control canvas
        height = len(task_list) * 180
        self.canvas = Canvas(self.root, width=970, height=height, scrollregion=(0,0,height,height))
        self.canvas.configure(bg="black")

        # Bind the mouse wheel movements with canvas
        self.canvas.bind_all("<MouseWheel>", self.on_mouse_wheel)
        self.canvas.pack()

        self.whole_page = Frame(self.canvas)
        self.whole_page.configure(bg="black")
        self.whole_page.pack()
        Label(self.whole_page, width = 100, text=scan_type + "  Scan  Result", bg="black", fg="white", font=("bold", 40)).pack(pady=5)

        # Create result info of each one task and put them on canvas
        self.tasks = tasks
        for task in self.tasks:
            self.frame_result = Frame(self.whole_page)
            self.frame_result.configure(bg="black")
            self.frame_result.pack(pady=10)
            
            # Use red colour to indicate malware and green colour for benign
            if task.result == "Benign":
                Label(self.frame_result, width=8, height=4, bg="green").pack(side=LEFT,padx=20)
            
            else:
                Label(self.frame_result, width=8, height=4, bg="red").pack(side=LEFT,padx=20)

            Button(self.frame_result, width=90, text=task.get_file_path(), bg="black", fg="white", font=("bold", 13), command= lambda file_path=task.get_file_path(), scan_type = scan_type, result = task.get_result(): self.check_detail(file_path, scan_type, result)).pack()
            Label(self.frame_result, width=20, text=task.get_result(), bg="black", fg="white", font=("bold", 20, 'bold')).pack(side=BOTTOM)

        self.frame_btn = Frame(self.whole_page)
        self.frame_btn.configure(bg="black", width=200)
        self.frame_btn.pack(side=BOTTOM, pady=20)

        Button(self.frame_btn, width=30, height=2, text="Back", command=self.back, bg='grey', fg='white', font=("bold",15)).pack(padx=30, side=LEFT)
        Button(self.frame_btn, width=30, height=2, text="Finish", command=self.finish, bg='grey', fg='white', font=("bold",15)).pack()

        # Put the scrollbar on canvas
        self.vbar = Scrollbar(self.canvas,orient=VERTICAL)
        self.vbar.place(x=930,width=20,height=500)
        self.vbar.configure(command=self.canvas.yview)
        self.canvas.config(yscrollcommand=self.vbar.set)
        self.canvas.create_window((460, 50*height/100), window=self.whole_page)

        self.root.mainloop()

# Record scan type
scan_type = ""

# Record task list
task_list = []

# Start the whole application
Start_screen()
